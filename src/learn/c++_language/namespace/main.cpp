#include <iostream>

namespace {

}

namespace nmsp1 {
	void print_nmsp1_count();
}

namespace nmsp2 {
	void print_nmsp2_count();
}

//一、标识符的作用域与可见性
// 1) 作用域从大到小依次为：
// a) 多文件作用域：可被多个源文件（编译单元）访问
// b) 单文件作用域：只能被当前源文件（编译单元）访问
// c) 类作用域：只能在类中被访问
// d) 函原型数作用域：只能在函数中被访问
// e) 块作用域（局部作用域）：只能在块中被访问
// 
// 2) 命名空间（namespace)
// 命名空间：在全局作用域中划分全局对象的归属权，将不同命名空间中的标识符严格区分，以消除程序不同模块中标识符相同带来的歧义
//  
// 3) 全局作用域（命名空间作用域）
// 全局作用域也称命名空间作用域，它包含了多文件作用域和单文件作用域，前者由默认命名空间和普通（有名）命名空间表示，后者由
// 匿名命名空间表示。所以多文件作用域被划分为 2 个大部分，属于默认命名空间的部分和属于有名命名空间的部分，所有在有名命名空
// 间之外声明的标识符都在默认命名空间中。而匿名空间用于表示单文件作用域，在匿名空间中声明的标识符只能在本源文件中使用，不可
// 被其他源文件直接访问（可通过函数调用间接访问）。需要注意，如果在多文件作用域用 static 修饰变量或函数，则该变量或函数的
// 作用域会变为单文件作用域。匿名命名空间实际上是 C 语言中 static 语义的延伸，static 只能用于修饰函数或变量，而不能用于修
// 饰一个类型（struct, class 等），而匿名命名空间则无此限制。一般匿名命名空间定义于文件最前面，类似于全局函数位置，之后的
// 命名空间可以正常访问匿名命名空间中的内容。注意，匿名命名空间是属于文件的，每个源文件都有属于自己的匿名命名空间，它用常常
// 用于屏蔽不希望暴露给其他源文件的标识符。最后，要理解匿名命名空间的单文件用域性，它只代表其它源文件不能直接访问匿名命名空
// 间的标识符，通过调用函数间接访问是可行的。
// 思考：命名空间的本质相当于编译器自动给所有的标识符都加上其所属命名空间的前缀，便于消除不同模块开发中标识符相同带来的歧义
// 在最终链接形成的可执行文件中，所有命名空间中的成员都可以理解为带有特殊前缀的标识符，空间分配与 C 语义中全局变量的空间分
// 配并无差别，生命周期也都是静态生命周期。这也是为什么可以通过调用全局函数访问其他源文件匿名命名空间中变量的原因（匿名命名
// 空间中的变量的空间分配与普通全局变量一样，变量也始终都在堆上，只不过是编译器在语法分析时禁止了其他源文件的直接访问而已）
// 
// 4) 命名空间的引用
// 语法：命名空间名::标识符名
// 需要注意，默认命名空间的引用是直接使用 :: 符号即可
// PS：默认命名空间也叫全局命名空间，所有没有置于某一具体命名空间下的代码即在默认命名空间下（main 函数必须置于默认命名空间下）
// 
// 5) using 语句的两种方法
// a) using namespace 命名空间名
// b) using 命名空间名::标识符
// 作用：在标识符前总使用命名空间进行限定会显得过于冗长，using 语句正是用来解决这一问题  
//
// 6) 类作用域
// a) 对于类中的所有成员变量，类的成员函数都可以直接访问，对于 public 成员变量，类外通过 X.m 或 *X->m 的形式访问
// b) 对于类作用域中的 public 静态成员变量或静态成员函数，在类外可以通过 "类名::标识符" 的形式进行直接访问
// 
// 7) 函数原型作用域
// 在函数原型声明时形式参数的作用范围就是函数原型作用域，所以所有的形参都只能在函数内部使用
// 
// 8) 局部作用域（块作用域） 
// 一对大括号括起来的程序块就是一个局部作用域，局部作用域中的变量称为局部变量
// 
// PS：不管在哪一个作用域中，要使用某一个标识符都需要在此之前先定义或先声明
// 
// 
//二、不同作用域间同名标识符的隐藏
//
//
//
//
int main() {
	// 通过调用全局函数访问其他源文件匿名命名空间中变量
	nmsp1::print_nmsp1_count();
	nmsp2::print_nmsp2_count();
	return 0;
}