#include <iostream>
#include <memory>
#include "time.h"
#include "human.h"
#include "man.h"
#include "women.h"
#include "function_hiding.h"

namespace _nmsp1 {
	class Student {
	public:
		int number;
	};

	class Time {
	public:
		int hour;
		int minute;
		int second;

	public:
		Time() : hour(0), minute(0), second(0) {
			
		}

		Time(int h, int m, int s) : hour(h), minute(m), second(s) {
		}

		void init_time( /* Time* this */ int h, int m, int s) {
			this->hour = h;
			this->minute = m;
			this->second = s;
		}

		void output() {
			std::cout << hour << ":" << minute << ":" << second << std::endl;
		}
	};
	
	// 指针本身进行的值传递，此处是借助指针来修改对象
	void init_time(Time* t, int h, int m, int s) {
		t->hour = h;
		t->minute = m;
		t->second = s;
	}

	class A {
	public:
		int m_i;
	};
}

namespace _nmsp2 {
	class Time{
	public:
		Time() :max_minute(59), max_second(59) {}
		int hour = -1;
		int minute = -1;
		int second = -1;
		static int num;

		const int max_hour = 23;
		const int max_minute;
		const int max_second;

	void output() {
			std::cout << "Time:" << hour << ":" << minute << ":" << second << std::endl;
		}

		void output_max() {
			std::cout << "max:" << max_hour << ":" << max_minute << ":" << max_second << std::endl;
		}
	};
	int Time::num;
}

namespace _nmsp3 {
	class Time {
	public:
		// 自己写一个不带参数的构造函数
		// Time() {};
		// 编译器为这种 = default 的函数自动生成函数体
		Time() = default;
		Time(const Time&) = delete;
		Time(int h, int m = 0, int s = 0) : hour(h), minute(m), second(s) {}
		int hour = 0;
		int minute;
		int second;


	public:
		void output() {
			std::cout << "Time:" << hour << ":" << minute << ":" << second << std::endl;
		}
	};
}

namespace _nmsp4 {
	class B;
	class A {
	public:
		A(int i) :m_i(i) {}

		int get_i() {
			return m_i;
		}

	private:
		int m_i;

	private:
		template<typename T, typename U>
		friend T& operator==(T& lhs, const U& rhs);
	};

	class B {
	public:
		B(int i) :m_i(i) {} 

		int get_i() {
			return m_i;
		}

	private:
		int m_i;

	private:
		template<typename T, typename U>
		friend T& operator==(T& lhs, const U& rhs);
	};

	template<typename T, typename U>
	T& operator==(T& lhs, const U& rhs) {
		lhs.m_i = rhs.m_i;
		return lhs;
	}

	class C {
	public:
		C(int i) :m_i(i) {
			std::cout << "C::C() 执行！" << std::endl;
		}

		~C(){
			std::cout << "C::~C() 执行！" << std::endl;
		}

		int get_i() {
			return m_i;
		}

	private:
		int m_i;
	};

}

namespace _nmsp5 {

}

namespace _nmsp6{
	class human {
		 
	};

}

namespace _nmsp6 {
	// 虚函数重写与协变返回类型
	class A {};
	class B : public A {};

	class Base {
	public:
		virtual A& show() {
			std::cout << "Base::show() 执行！" << std::endl;
			return *(new A);
		}

		virtual void hide() {
			std::cout << "Base::hide() 执行！" << std::endl;
		}
	};

	class Derived : public Base {
	public:
		// 返回值协变，构成虚函数重写
		virtual B& show() override {
			std::cout << "Derived::show() 执行！" << std::endl;
			return *(new B);
		}

		void hide(int) {
			std::cout << "Base::hide() 执行！" << std::endl;
		}
	};
}

void test1() {
	// (1.1) 综述
	std::cout << "<----------(1.1) 综述---------->" << std::endl;
	// a) 类是自定义的新类型
	// b) 站在设计者和实现者的角度来考虑
	// c) 站在使用者的角度考虑
	// d) 类的抽象与类之间的关系（如父子继承关系，组合关系等）
	// e) 类对象成员的访问："对象名.成员名" 或 "对象指针->成员名"
	// f) public:表示暴露给用户使用的类成员，private:管理用于类实现细节的类成员，仅用于类内部使用
	// g) struct 是权限默认为 public 的 class (class 默认的权限为 private)
	// struct A{......} 等价于 class{pibic:......}
	_nmsp1::Student s;
	s.number = 1000;
	std::cout << "s.number = " << s.number << std::endl;
	_nmsp1::Student* p = &s;
	p->number = 1200;
	std::cout <<"p->number = "<< p->number << std::endl;
	std::cout << std::endl;

	// (1.2) 初始化类的成员变量 
	std::cout << "<----------(1.2) 初始化类的成员变量---------->" << std::endl;
	// a) 传统的 C 语言结构体初始化方法（直接赋值）
	_nmsp1::Time t1;
	_nmsp1::init_time(&t1, 10, 11, 12);
	t1.output();
	// b) 成员函数初始化
	t1.init_time(12, 11, 10);
	t1.output();
	// c) 构造函数初始化
	_nmsp1::Time t2(12, 30, 45);
	t2.output();
	std::cout << std::endl;

	// (1.3) 将类（或函数）的定义和实现分别放在 .h 与 .cpp 文件中
	std::cout << "<----------(1.3) 将类（或函数）的定义和实现分别放在 .h 与 .cpp 文件中---------->" << std::endl;
	// 对于用户自己实现的类或函数，一般将其声明单独放在一个 .h 文件内，将其实现单独放在一个 .cpp 文件内（类模板与函数模板除外）
	// 在需要使的地方 #include .h 文件即可，.h 文件只是一份声明，声明在当前编译单元可以使用哪些类和函数
	// 而并不去寻找这些函数和类的具体实现（至于寻找类和函数具体代码实现并且合并进入当前代码的问题会交给链接器去执行）
	// 基于上述原因，.h 文件总会被需要使用它的 .cpp 文件 #include，所以我们并不需要在执行编译时包含 .h 文件
	// 例如使用 g++ 编译时指令类似于 g++ -Wall -g -O0 -std=c++17 main.cpp time.cpp -o main，可以看到 
	// 编译时并不包含 .h 文件，原因正每个 .cpp 文件中已经包含了所需的 .h 文件了。在编译的预处理阶段，预处理器
	// 会先到工程目录下去寻找用户自定义的 .h 文件，然后再到用户指定的 #include 目录下去寻找第三方库的 .h 文件
	// 最后到系统默认的 #include 目录下去寻找系统提供的或者其他的 .h 文件。所有的 .h 文件中的内容会被嵌入在 .cpp 
	// 文件指定的位置并声明可能用到的类与函数。与 .h 文件不同，用户编写的用于实现 .h 文件中类和函数的 .cpp 文件则
	// 必须被指定加入编译过程，编译器会编译这些 .cpp 文件并生成相应的二进制目标文件供链接器使用（此处链接器的工作
	// 正是前文提及的寻找类和函数具体代码实现并进行代码的合并最终生成二进制可执行文件）
	// 对于第三方库或系统提供的库，则并不需要指定相关的 .cpp 文件，与它们的相关代码早已经被编译成了二进制目标文件
	// 并打包作为动态链接库或静态链接库提供给了用户，用户只需要在使用相关库函数或类的地方 #include .h 文件即可
	// 在编译器的链接阶段，链接器会先到用户指定的库目录中寻找使用到的库代码，然后到系统默认的库目录中寻找使用到的
	// 库代码（如果库同时提供静态链接库和动态链接库，则优先使用动态链接库
	_nmsp::Time t3(12, 24, 46);
	t3.output_time();
	std::cout << std::endl;
	
	// (1.4) 对象的拷贝
	// 默认情况下，是每个成员变量逐个拷贝（简单的值拷贝）
	std::cout << "<----------(1.4) 对象的拷贝---------->" << std::endl;
	_nmsp::Time t4(0, 0, 0);
	// 实测下来，下列四种形式都是调用的拷贝构造函数
	_nmsp::Time t5(t4);
	_nmsp::Time t6 = t4;
	_nmsp::Time t7{ t4 };
	_nmsp::Time t8 = { t4 };
	// 只调用了一次构造函数，没有调用拷贝构造函数，这是编译器优化的结果
	_nmsp::Time t9 = _nmsp::Time(0, 0, 0);
	// 调用的赋值运算符
	(t9 = t4).output_time();
	std::cout << std::endl;

	// (1.5) 私有成员
	std::cout << "<----------(1.5) 私有成员---------->" << std::endl;
	_nmsp::Time t10(10, 58, 49);
	t10.set_timer(12);
	std::cout << "t9.microsecond = " << t10.get_microsecond() << std::endl;
}

void test2() {
	// (2.1) 构造函数详解 
	std::cout << "<----------(2.1) 构造函数详解---------->" << std::endl;
	// 构造函数是特殊的成员函数，函数名与类名相同并且没有返回值
	// 在创建类对象的时候，系统会自动调用构造函数对类的成员进行初始化
	// 需要注意以下几点：
	// a) 构造函数无返回值且不用 void 代表无返回值
	// b) 构造函数无法被手动调用，只能由系统自动调用
	// c) 一般情况下，构造函数应该被声明为 public，这样系统才能在类外调用构造函数来创建对象
	// 一个例外是单例模式，单例模式类的构造函数应该保留为 private，放置类在外部被创建 
	// 下列所有写法都只调用了一次构造函数，说明编译器对构造函数有优化
	_nmsp::Time t1(10, 11, 12);
	_nmsp::Time t2 = _nmsp::Time(10, 11, 12);
	_nmsp::Time t3{ 10, 11, 12 };
	_nmsp::Time t4 = _nmsp::Time{ 10, 11, 12 };
	// 进行了隐式类型转换 
	// 报错：复制列表初始化不能使用标记为 explicit 的构造函数
	// _nmsp::Time t5 = { 10, 11, 12 };
	std::cout << std::endl;

	// (2.2) 构造函数重载
	std::cout << "<----------(2.2) 构造函数重载---------->" << std::endl;
	// 报错：未调用原型函数(是否是有意用变量定义的?)
	// _nmsp::Time t6();
	// 下列所有写法都只调用了一次构造函数，说明编译器对构造函数有优化
	_nmsp::Time t6;
	_nmsp::Time t7 = _nmsp::Time();
	_nmsp::Time t8{};
	_nmsp::Time t9 = _nmsp::Time{};
	_nmsp::Time t10 = {};
	std::cout << std::endl;

	// (2.3) （成员）函数默认参数
	std::cout << "<----------(2.3) 函数默认参数---------->" << std::endl;
	// 1)（成员）函数的默认值只能放在类的声明中（除非该函数没有函数声明）
	// 2) 在给具有多个参数的函数指定默认值时，所有含默认值的参数只能依次放在最右边
	// 3) 使用带默认参数的函数可能导致重载冲突
	_nmsp::Time t;
	t.init_time(12, 30, 45);
	t.output_time();
	t.init_time(12,30);
	t.output_time();
	t.init_time(12);
	t.output_time();
	std::cout << std::endl;

	// (2.4) 隐式类型转换
	std::cout << "<----------(2.4) 隐式类型转换---------->" << std::endl;
	// 单参数的构造函数可能造成隐式类型转换，这种隐式类型转换可能是并非程序员的本意
	// 由隐式类型转换带来的问题不容易排错，所以非必要条件下应当警用隐式类型转换，并使用强制类型转换
	// 使用 explicit 可以禁止隐式类型转换，使得单参数构造函数只能用于初始化和显式类型转换

	//// 报错：复制列表初始化不能使用标记为 explicit 的构造函数
	//_nmsp::Time tt = { 10 };
	//tt.output_micro();
	//// 构造对象含糊不清
	//_nmsp::Time tt1 = 20;
	//tt1.output_micro();
	//// 这种写法是不可接收的
	//_nmsp::Time tt2 = (1, 2, 3, 4, 5, 30);
	//tt2.output_micro();
	//// 函数传参含糊不清
	//_nmsp::deal_time(40);

	_nmsp::Time tt = _nmsp::Time{ 10 };
	tt.output_micro();
	_nmsp::Time tt1 = _nmsp::Time(20);
	tt1.output_micro();
	_nmsp::deal_time(_nmsp::Time(40));
	std::cout << std::endl;
}

void test3() {
	// (3.1) 类内的成员函数实现（inline)
	std::cout << "<----------(3.1) 类内的成员函数实现（inline)---------->" << std::endl;
	// 直接在类中实现的函数会被当作 inline 函数处理（inline 处理可以减少函数调用，提高效率）
	// inline 函数只是一种对编译器的建议，最终是否内联处理取决于编译器
	// 如果想要提高 inline 处理的概率，则代码要尽量简短且调用频率非常高
	_nmsp::Time t(12, 30);
	t.output_time();
	t.add_hour(2);
	t.output_time();
	std::cout << std::endl;

	// (3.2) 常成员函数
	std::cout << "<----------(3.2) 常成员函数---------->" << std::endl;
	// 注意：如果要使用常成员函数，需要在成员函数的声明和定义中都加上 const
	// 常成员函数的作用：表示该成员函数不会修改类对象中任何成员变量的值（也就是说该成员函数不会影响类的状态） 
	// 对于 const 对象，只能调用常成员函数。对于普通对象，既可以调用普通成员函数，也可以调用 const 成员函数
	// 因为编译器无法通过具体的代码区分哪些函数会影响对象的状态，所以只有明确指定的 const 成员函数才能被 const 对象调用
	const _nmsp::Time t1(12, 24, 36);
	t1.output_time();

	// 尝试通过指针或引用越过 const 权限
	const _nmsp::Time t2(12, 24, 36);
	// a) 用引用尝试越过
	// 实际情况下越过失败，报错：无法从 const int 转换为 int &
	std::cout << "t2.hour = " << t2.get_hour() << std::endl;
	// b) 用指针尝试越过
	// 实际情况下越过失败，报错：无法从 const int* 转换为 int*
	std::cout << "t2.minute = " << *t2.get_minute() << std::endl;
	// c) 是否能直接调用 public 成员函数
	// 显然是不能的，一旦定义 const 对象，则该对象的所有成员函数自动加上了 const 修饰
	// 所以 hour 的实际类型是 const int hour，t2.hour = 12 相当于要对常量赋值，所以是错误的，不能通过编译
	// t2.hour = 12;

	// 思考，既然 const 对象的所有成员函数都是常量，那么有以下几个问题
	// 1) 如果类的构造函数没有对成员变量进行初始化值会如何？
	// 遇到的第 1 个问题：编译器警告，使用编译器生成的默认构造函数初始化的 "const" 自动数据会产生不可靠的结果
	// 问题的原因：由于类的对象是在堆栈上生成的，因此成员变量的初始值可以是任何值
	// 此外，由于它是 const 对象，因此成员变量的值永远不会被更改，这个成员变量几乎毫无意义
	//const _nmsp1::A a;
	// 遇到的第 2 个问题：编译器直接报错，使用未初始化的局部变量
	// std::cout << "a.m_i = " << a.m_i << std::endl;
	// 2) 常成员函数的真正作用：常成员函数本质上是用来帮助编译器进行语法检查的
	// 由于在对类进行定义时，无法知道哪些函数可能被 const 对象调用，而针对 const 对象的
	// 语法检查必须将 const 对象的成员变量当作常量处理，这一点有别于普通对象的语法检查
	// 所以 const 成员函数正是显式的指定了使用针对 const 对象的语法对函数进行语法检查
	std::cout << std::endl;

	// (3.3) mutable 
	std::cout << "<----------(3.3) mutable---------->" << std::endl;
	// a) mutable 表示不稳定、容易改变的意思，是 const 的反义词
	// b) mutable 的作用正是用来突破 const 的限制，用于解决想要修改 const 对象中某个成员变量值的问题
	// c) 思考一下什么情况会用到？
	// 应该是绝大多数的成员变量希望是 const 变量，有 1 个或 2 个变量又有修改的需求时
	// d) 一但类中的成员变量被 mutable 修饰，则表示该成员变量永远处于可以修改的状态，即便是在 const 成员函数中也可以修改
	const _nmsp::Time t3(12, 30);
	std::cout << "t3.valid = " << t3.valid << std::endl;
	t3.valid = false;
	std::cout << "t3.valid = " << t3.valid << std::endl;
	std::cout << std::endl;

	// (3.4) return *this 与 return this
	std::cout << "<----------(3.4) return *this 与 return this---------->" << std::endl;
	// 在调用成员函数时，编译器负责把对象的地址传递给一个隐藏的形参，这个形参就是 this 指针
	// 任何对类成员的直接访问都被看作是通过 this 做隐式调用的
	// 可以想到，类的成员函数其实就是传递了对象指针的普通函数，而类的作用域解析符就是限定了这些
	// 成员函数是属于类的，而不是全局的，这里已经可以稍微感觉到 C++ 的对象模型了
	// 下面有一些注意事项：
	// a) this 本身具有的 const 属性，也就是说不可以修改 this 本身所指向的地址 
	// b) this 指针只能在成员函数中使用，全局函数以及静态成员函数都不能使用（其实这里也能看出要隐藏 this
	// 指针的目的：由于类中的变量是属于类的，所以应该通过 this 指针给类的成员函数使用，但是
	// 如果可以显式的传递 this 指针，那么就可以将 this 指针传递给外部函数，那外部函数岂不是也可以访问
	// 类的成员变量，这样就破坏了类的封装性）
	// c) 在普通成员函数中，this 是指向非 const 对象的 const 指针（在此处应该是 Time * const this)
	// 在 const 成员函数中，this 是指向 const 对象的 const 指针（在此处应该是 const Time* const this)
	// 也就是说，无论指向的对象是否为 const 对象，this 本身是一个常量，不能修改 this 让其指向另一个对象
	_nmsp::Time t4(12, 30);
	// 问题: 实际上 t4 只加了一次，因为前置++ 加到了一个零时对象上，并没有加到原对象上
	std::cout << ++(t4++);
	t4.get_self()->output_time();
	std::cout << std::endl;

	// (3.5) static 成员
	std::cout << "<----------(3.5) static---------->" << std::endl;
	// 1) static 修饰普通函数的局部变量，则该变量为静态局部变量
	// 其内存分配在堆上，具有函数作用域，静态生命期
	
	// 2) static 修饰全局变量，则该变量为静态全局变量
	// 其内存分配在堆上，具有文件作用域，静态生命期
	// 以上 2 种变量如果不初始化值，系统自动将其初始化为 0
 
	// 3) static 修饰的类成员变量用于定义属于类的属性，这个属性是整个类的，而不属于某个对象
	// a) 如果静态成员变量是 public 访问权限，则可以用作用域解析符直接访问，
	// 当然也可以通过类的对象访问，因为该变量是属于整个类的，而不属于某个对象
	// b) 静态成员变量需要在内外单独初始化，因为静态成员变量的空间分配在堆上
	// 在类中，只是有一个指针指向静态成员变量
	std::cout << (_nmsp::Time::num = 10) << std::endl;
	std::cout << _nmsp::Time::get_num() << std::endl;

	// 4) static 修饰的类成员函数，一般用来初始化或处理静态成员变量，可以用作用域解析符直接调用
	// 静态成员函数是属于整个类的，完全可能在没有创建任何类对象时被调用，它的使用与类的具体对象无关
	// 所以编译器不会隐式传递对象的 this 指针给静态成员函数，也就是说静态成员函数不能访问或修改普通成员函数
}

void test4() {
	// (4.1) 类相关的成员函数
	std::cout << "<----------(4.1) 类相关的成员函数---------->" << std::endl;
	_nmsp::Time t;
	print(t);
	std::cout << std::endl;

	// (4.2) 类内初始值（不推荐使用，但要认识）
	std::cout << "<----------(4.2) 类内初始值---------->" << std::endl;
	// 在 C++11 里，可以为类内的成员变量提供一个初始值，当我们在创建对象的时候，该初始值用于初始化该成员变量
	// 如果不提供类内初始值，也没有用构造函数初始化，则使用缺省的初始策略。如果时普通成员变量，则是未知值
	// 如果是静态成员变量，则默认初始值为 0
	_nmsp2::Time t1;
	t1.output();
	std::cout << "未初始化的静态局部变量 t.num = " << t1.num << std::endl;
	std::cout << std::endl;

	// (4.3) const 成员变量的初始化
	std::cout << "<----------(4.3) const 成员变量的初始化---------->" << std::endl;
	// 对于 const 成员变量，只能使用初始化列表或类内初始值来初始化
	// 如果不初始化 const 成员变量直接报错
	_nmsp2::Time t2;
	t2.output_max();
	std::cout << std::endl;

	// (4.4) 默认构造函数
	std::cout << "<----------(4.4) 默认构造函数---------->" << std::endl;
	// 在运行时生成类，是会分配空间并调用构造函数构造对象的，那没有构造函数的类是如何初始化的呢？
	// 实际上是调用了特殊的构造函数来执行默认的初始过程，这个特殊的构造函数是编译器生成的缺省 "默认构造函数"
	// 这个默认构造函数被称为 "合成的默认构造函数"
	// 如果使用了类内初始值，"合成默认构造函数" 将值赋予成员变量，如果没有使用类内初始值，则成员变量为随机值
	_nmsp3::Time t3;
	// 下列代码调用后，hour 有初值为 0，minute 和 second 则是随机值
	t3.output();
	// 注意
	// a) 如果类中有类类型的成员变量，且该类类型成员变量无默认构造函数，只有含参构造函数
	// 此时不能使用 "合成默认构造函数"，必须自己实现构造函数并在初始化列表中向类类型成员变量的构造函数传参
	// b) 如果自己实现了构成函数，则编译器不会创建 "合成默认构造函数"
	std::cout << std::endl;

	// (4.5) = default 与 = delete
	std::cout << "<----------(4.5) = default 与 = delete---------->" << std::endl;
	// = default 的作用是为函数自动生成函数体（只适用于默认构造函数，默认拷贝构造函数，默认赋值运算符，析构函数等）
	// 带参数的函数不能使用 = default
	_nmsp3::Time t4;
	t4.output();

	// = default 的作用是显式的禁用某个函数（比如默认构造函数，默认拷贝构造函数，默认赋值运算符等）
	// 报错：使用已删除的函数
	// _nmsp3::Time t5 = t4;
}

void test5() {
	// (5.1) 拷贝构造函数
	std::cout << "<----------(5.1) 拷贝构造函数---------->" << std::endl;
	// a) 系统生成的缺省拷贝构造函数是简单的值拷贝
	// b) 如果一个类的构造函数的第一个参数是所属类类型的引用，并且其他额外参数都有默认值
	// (默认参数必须放在函数声明中，除非没有函数声明）则这个构造函数是拷贝构造函数
	// c) 如果我们没有定义拷贝构造函数，则编译器会自动生成一个默认拷贝构造函数进行值拷贝
	// d) 注意类组合与类继承过程中拷贝构造函数的递归调用过程
	// e) 如果我们自定义了拷贝构造函数，则系统不会在生成默认拷贝构造函数
	_nmsp::Time t(0, 0, 0);
	// 实测下来，下列四种形式都是调用的拷贝构造函数
	_nmsp::Time t1(t);
	_nmsp::Time t2 = t;
	_nmsp::Time t3{ t };
	_nmsp::Time t4 = { t };
	// 只调用了一次构造函数，没有调用拷贝构造函数，这是编译器优化的结果
	_nmsp::Time t5 = _nmsp::Time(0, 0, 0);
	// 调用的赋值运算符
	t5 = t;
	std::cout << std::endl;
	// 会调用拷贝构造函数的情况
	// a) 将类作为实参进行值传递的时候
	// b) 返回一个类进行值传递时
	// 返回时只调用了一次拷贝构造函数，明显是编译器进行了优化
	auto t6 = call_time(t5);

	// (5.2) 类对象返回时编译器的优化
	// std::cout << "<----------(5.2) 类对象返回时编译器的优化---------->" << std::endl;
	// 拷贝构造函数可能有多种优化
	// 自己深入学习
}

void test6() {
	// (6.1) 重载运算符
	// std::cout << "<----------(6.1) 重载运算符---------->" << std::endl;
	// 可以重载的运算符有 ==, >, >=, <, <=, =, !=, +=, -=, *=, /=, +, -, ++, --, <<, >>, new, delete等
	// 重载运算符有点像 java 中 implements 约定 interface
	// 如果在类内重载，则表示运算符左边的参数默认为该类的对象，同时在实现重载函数时，可以直接使用类的成员变量
	// 如果在类外重载，则可以指定参与运算的 2 个参数，但由于重载函数不是类的成员函数，故不能直接使用类的成员变量（此问题可以用友元解决）
	// 之所以类内重载会比类外重载少一个参数的原因很简单，就是类内重载是作为类的成员函数，编译器会隐式传递一个 this 指针作为其中一个参数
	// 这也是为什么运算符重载不能是 static 函数的原因，static 函数不会隐式传递 this 指针，这样运算符重载函数就少了一个参与运算的参数
	// （有空再来细研究）


	// (6.2) 重载拷贝运算符（拷贝运算符与拷贝构造函数的区别）
	std::cout << "<----------(6.2) 重载拷贝运算符---------->" << std::endl;
	// 缺省情况下，编译器会生成一个默认的复制运算符，并进行简单的值拷贝（逐个复制非 static 成员变量）
	// 编译器生成的默认构造函数不能处理动态内存的拷贝和删除等问题，
	// 拷贝赋值运算符的返回值，参数比较固定，大致如下:
	// Time& operator= (const Time &)
	// 之所以使用 const & 的原因是为了对 const 对象进行拷贝
	

	// (6.3) 拷贝运算符与拷贝构造函数的区别
	std::cout << "<----------(6.3) 拷贝运算符与拷贝构造函数的区别---------->" << std::endl;
	// a) 拷贝构造函数用于构造新的对象，即拷贝构造函数使用已有的对象创建一个新的对象
	_nmsp::Time t;
	// 显式调用拷贝构造函数
	_nmsp::Time t1(t);
	// 隐式调用拷贝构造函数
	_nmsp::Time t2 = t;
	// b) 赋值运算符重载用于将源对象的内容拷贝到目标对象，若源对象中包含未释放的内存需要先将其释放
	// 赋值运算符是将一个对象的值复制给另一个已存在的对象，区分是调用拷贝构造函数还是赋值运算符，主要看是否有新的对象产生
	t1 = _nmsp::Time(12, 30);
	// c) 赋值运算符重载可以有返回值，一般返回值为对象本身，这样可以使用连续调用
	(t2 = t1).output_time();
	// d) 一般情况下，类中有指向动态内存的指针变量时，需要手动实现拷贝构造函数、析构函数以及重载赋值运算符
	std::cout << std::endl;


	// (6.4) 析构函数
	std::cout << "<----------(6.4) 析构函数---------->" << std::endl;
	// 缺省情况下，编译器会生成一个默认的析构函数，默认析构函数会调用类类型成员的析构函数进行递归析构
	// 但默认的析构函数并不能处理动态分配的内存（比如 new 出来的内存，并不会被 delete)
	// 析构函数也是类的成员，它的名字是由~加类名构造，没有返回值，不接受任何参数，不能被重载
	// 所以一个给定的类，只有唯一的析构函数（函数重载要求函数形参的数目或类型不同，返回值类型不能作为函数重载的依据）
	_nmsp4::C c(1);
	std::cout << std::endl;
	// 关于析构函数的思考
	// 析构函数只是用来做额外的清理工作的，类的成员变量还是编译器自动销毁的，且销毁顺序正好和定义顺序相反
	// 构造函数先执行构造函数的初始化列表，再执行构造函数的函数体进行一些额外的初始化工作
	// 析构函数先执行函数体进行一些额外的清理工作，再执行成员对象的销毁工作
	// 成员变量初始化和销毁的时机：先定义的先初始化，销毁时先定义的后销毁
	// 成员变量的初始化顺序由其定义顺序决定，成员变量的析构顺序与初始化顺序正好相反

	// (6.x) 一些思考
	std::cout << "<----------(6.x) 一些思考---------->" << std::endl;
	// 思考，如果有如下指向容器的 shared_ptr，在进程fork 的时候，会进行深度拷贝吗？（也就是会复制容器内部的值吗？)
	// std::shared_ptr<std::vector<int>> ptr(new std::vector<int>());
	// 思考1：友元函数的好处，可以同时使用多个类中的成员变量，在需要使用成员变量的跨类型操作中会非常方便
	_nmsp4::A a(1);
	_nmsp4::A b(2);
	std::cout << "a.m_i = " << a.get_i() << std::endl;
	a = b;
	std::cout << "a.m_i = " << a.get_i() << std::endl;
	// 思考2：public 和 private 修饰友元函数的区别
}

void test7() {
	// (7.1) 继承与派生
	// 继承与派生是表示类之间层次关系的一种方式，也是面向对象程序设计的核心思想（父类 / 基类 / 超类）（子类 / 派生类）
	// 一般父类中放一些公用的成员变量和成员函数，子类通过继承父类的成员函数和成员变量来进行代码复用
	// 继承与派生的好处在于代码复用和代码扩充，通过继承可以充分使用已有的代码，在此基础根据实际问题对代码进行改造和扩充
	
	// (7.2) 构造函数调用顺序 
	// 当定义子类对象是，先调用父类构造函数，再调用子类构造函数
	nmsp::Man m;
	std::cout << std::endl;

	// (7.3) 访问修饰符
	// public：可以被任意实体直接访问
	// protected：只允许本类或子类的成员函数直接访问
	// private：只允许本类的成员函数直接访问
	
	// 基类中的访问权限	子类继承基类的继承方式	子类得到的访问权限
	// public			public					public
	// protected		public					protected
	// private			public					不可直接访问
	// 
	// public			protected				protected
	// protected		protected				protected
	// private			protected				不可直接访问
	// 
	// public			private					private
	// protected		private					private
	// private			private					不可直接访问
	
	// 总结
	// 1) 父类中的 private 成员不受继承方式的影响，子类永远无权直接访问
	// 2) public 继承不改变父类成员的访问权限（private 成员除外）
	// 3) protected 继承将父类中 public 成员变为子类的 protected 成员
	// 4) private 继承使得父类所有成员在子类中的访问权限变为 private（private 成员除外）
	// 5) 对于父类成员函数，如果不想让外部访问，则设置为 private，如果像让子类访问
	// 则设置为 protected，如果想要公开，则设置为 public
	
	// (7.4) 函数隐藏（Function Hiding）
	// 函数隐藏也叫同名隐藏，通常是指不同作用域中定义的同名函数导致的函数遮蔽行为
	// 较小作用域中的同名函数会隐藏较大作用域中的同名函数（无论函数的返回值，形参类型是否相同）

	// 1) 同名隐藏的几种类型
	// a) 父命名空间与子命名空间之间的同名隐藏
	parent_nmsp::sub_nmsp::test();
	std::cout << std::endl;
	// b) 类内与内外之间的同名隐藏
	parent_nmsp::Base().test();
	std::cout << std::endl;
	// c) 基类和派生类之间的同名隐藏
	parent_nmsp::Derived().test();
	std::cout << std::endl;

	// 2) 父类，子类含虚函数的同名隐藏
	// a)
	// 
	// b)
	// 
	// c)

	// (7.5) 思考
	// 1) 函数重载（Function Overload）
	// 定义：C++规定在同一作用域中，同名函数的形式参数（指参数的个数、类型或者顺序）不同时，构成函数重载
	// a) 函数返回值类型与构成函数重载无任何关系
	// b) 类的静态成员函数与普通成员函数之间可以形成重载（因为这两个函数在同一个作用域内）
	// c) 函数重载只会发生在具有相同作用域的同名函数之间，而不会在跨越作用域的函数之间形成重载
	// 也就是说，只会在类的成员函数之间、普通的全局函数之间、相同命名空间的函数之间发生重载
	// 而不会在父命名空间函数与子命名空间函数之间、类内成员函数与类外普通全局函数之间，父类成员函数与
	// 子类成员函数之间发生重载，以上三种不同作用域之间有同名函数的情况会形成函数隐藏而不是函数重载

	// 2) 函数隐藏（同名隐藏）（Function Hiding）
	// 定义：函数隐藏指不同作用域中定义的同名函数构成函数隐藏（不要求函数返回值和函数参数类型相同）
	// 例如派生类成员函数屏蔽全部与其同名的基类成员函数、类内成员函数屏蔽全部与其同名的外部普通函数
	// 为什么会有函数隐藏？同名隐藏是一种编译器的自然行为，就像局部变量遮蔽全局变量一样
	// 根本原因是编译器无法区分是调用父作用域的同名函数还是子作用域的同名函数
	// 跨作用域的同名函数调用给编译器的分析带来了混乱，解决方法是使用作用域解析符或 using 语句
	// 注意事项：
	// a) 函数隐藏与函数的返回值类型，形参的个数，形参的类型无关，只要同名即可构成函数隐藏
	// b) 如果在派生类中存在与基类虚函数同返回值、同名且同形参的函数，则构成函数覆盖（函数重写）
	// c) 在 C++11 中，可以使用 using 语句让父类中的同名函数在子类中可见，并直接调用（突破函数隐藏）
	// d) 子类中的同名普通函数会隐藏父类中的同名虚函数
	// 需要注意：
	// I： using 语句会让父类中的同名函数在子类中以重载函数的方式来使用
	// II：如果父类与子类中存在形参类型与个数都相同的同名函数，则调用子类中的同名函数
	// III：using 语句也可以让父命名空间中的同名函数在命名空间中可见，并直接调用
	// IIII：使用 using 语句无法指定某个具体的函数，即无法让某个或某些父类中的同名函数在子类中可见
	// 可以想见，C++ 引入 using 语句的主要目的是让子类可以调用父类中同名函数的重载版本
	// 而对于哪些与父类同名同参的函数，则使用子类中自己实现的版本，从而实现代码的复用与扩充
	// 值得一提：经过测试，无法使用 using 语句让类外中的同名函数在类内中可见

	/////////////////////////////////////////////////////////////////////////////
	////// 函数隐藏的调用实际上是静态绑定的，在编译时就确定了需要调用的函数，而使用虚函数的函数覆盖是动态绑定
	////// 在代码运行过程中才知道实际需要调用的函数
	/////////////////////////////////////////////////////////////////////////////
 
	
	// 3) 函数覆盖（函数重写）（Function Override）
	// 定义：派生类中与基类同返回值类型、同名和同参数的虚函数重定义，构成虚函数覆盖，也叫虚函数重写 
	// 关于返回值类型存在一种特殊情况，即协变返回类型（covariant return type）
	// 如果虚函数函数返回指针或者引用时（不包括 value 语义，即并不包含值传递的语义）
	// 子类中重写的函数返回的指针或者引用是父类中被重写函数所返回指针或引用的子类型（这就是所谓的协变返回类型）
	std::unique_ptr<_nmsp6::Base> p = std::make_unique < _nmsp6::Derived>();
	p->_nmsp6::Base::show();
	p->show();
	// a) 函数覆盖就是虚函数重写，而不是函数被 "覆盖"，从上面的代码可以看出，函数是不可能被 "覆盖" 的
	// 有些人可能会错误地认为函数覆盖会导致函数被 "覆盖" 而 "消失"，从而不能够再被访问
	// 事实上只要通过作用域运算符::就可以访问到被覆盖的函数
	// b) 对比函数覆盖和函数隐藏的定义，不难发现函数覆盖其实是函数隐藏的特例
	// 如果派生类中定义了一个与基类虚函数同名但参数列表不同的非 virtual 函数，则此函数是一个普通成员函数（非虚函数）
	// 并形成对基类中同名虚函数的隐藏，而非虚函数覆盖（重写）
	// 《C++高级进阶教程》中认为函数的隐藏与覆盖是两个不同的概念。隐藏是一个静态概念，它代表了标识符之间的一种屏蔽现象
	// 而覆盖则是为了实现动态联编，是一个动态概念。但隐藏和覆盖也有联系：即形成覆盖的两个函数之间一定形成隐藏。
	// 例如，可以对虚函数采用 "实调用"，即尽管被调用的是虚函数，但是被调用函数的地址
	// 还是在编译阶段静态确定的，那么派生类中的虚函数仍然形成对基类中虚函数的同名隐藏
	_nmsp6::Base b;
	_nmsp6::Derived d;
	b.show();			// 对函数 show() 的 "实调用"，因为编译期可以确定调用函数的地址
	d.show();			// 对函数 show() 的 "实调用"，因为编译期可以确定调用函数的地址
	_nmsp6::Base* vp = &d;
	vp->show();			// 对函数 show() 的虚调用
	vp->Base::show();	// 对函数 show() 的 "实调用"，因为编译期可以确定调用函数的地址
	std::cout << std::endl;

	// 测试子类普通成员函数对父类同名虚函数的隐藏
	_nmsp6::Derived test;
	// 确实发生了子类普通成员函数对父类同名虚函数的隐藏
	// test.test6();
	// 使用作用域解析符可以正常调用父类虚函数
	test._nmsp6::Base::hide();
	test.hide(1);
	std::cout << std::endl;
	// 总结：
	//（1）函数重载发生在相同作用域；
	//（2）函数隐藏发生在不同作用域；
	//（3）函数覆盖就是函数重写,准确地叫作虚函数覆盖和虚函数重写，也是函数隐藏的特例
	//（4）子类普通成员函数会将父类的同名虚函数隐藏 

	// 待解决问题 1：Lambda 表达式是否可以构成函数重载？？？ Lambda 表达式是否可以构成函数隐藏
	// 待解决问题 2：using 语句的作用有哪些
}

void test8() {
	// (8.1) 基类指针指向派生类对象
	std::shared_ptr<nmsp::Human> p = std::make_shared<nmsp::Man>();
	// 可以调用父类的成员函数
	p->human_func();
	// 报错::调用函数不是 Human 类或其基类的成员函数
	// 这说明即使父类指针实际指向子类对象，也无法通过父类指针调用子类的成员函数
	// p->nmsp::Man::man_func();
	// 开发中的实际需求是：如果父类指针指向子类对象，则通过父类指针
	// 既可以调用父类中的成员函数，又可以调用子类中的同名同参成员函数
	
	// 如何解决呢？可以考虑将父类指针转换为子类指针
	// 遇到问题，unique_ptr 如何进行父类指针转子类指针呢？
	std::shared_ptr<nmsp::Man> p1 = std::dynamic_pointer_cast<nmsp::Man>(p);
	p1->man_func();
	// 由此可以提出一个问题？既然父类指针无法调用子类的成员函数，那为何允许父类指针指向一个子类对象
	std::cout << std::endl;
	// 也可以考虑使用虚函数，不过虚函数相比父类指针转子类指针要求函数同名（相对而言不够灵活）


	// (8.2) 虚函数
	// 作用：满足实际开发中的需求，即通过父类指针调用父类、子类中的同名同参的函数
	// 要求 1：指向实际对象的指针必须是父类的指针
	// 要求 2：在父类中将有这样需求的函数声明为虚函数（virtual function)
	// PS：如果要使用虚函数，则在父类的成员函数前加入 virtual 声明是必须的，对于子类的同名同参函数
	// 是否在其前加入 virtual 声明并无影响，因为所有子类中的同名同参函数都自动默认为 virtual 函数
	// 实际开发中推荐在子类函成员数前加入 virtual 声明，这样做可以提高代码的可读性	
	std::unique_ptr<nmsp::Human> vp = std::make_unique<nmsp::Human>();
	std::unique_ptr<nmsp::Human> vpm = std::make_unique<nmsp::Man>();
	std::unique_ptr<nmsp::Human> vpw = std::make_unique<nmsp::Woman>();
	vp->eat();
	vpm->eat();
	vpm->nmsp::Human::eat();
	vpw->eat();
	vpw->nmsp::Human::eat();
	std::cout << std::endl;

	// override 关键字（虚函数专用）：用于在子类中明确指出某一个函数是对父类虚函数的覆盖（重写），目的是为了防止
	// 在子类中误写函数的参数个数或类型，导致最终发生函数隐藏（同名隐藏），而不是虚函数覆盖
	// 使用了 override 关键字，则编译器会尝试在父类中寻找同名同参的虚函数，如果找不到，则可能是
	// 是写错参数的数量或类型，这样可以帮助我们纠错

	// final 关键字（虚函数专用）：如果将父类中虚函数声明为 final，那么子类中任何尝试覆盖该函数的操作都将引发错误
	
	// 调用虚函数进行的是 "动态绑定"，动态表示在程序运行期才能决定类的对象绑定到那一个具体函数上运行
	// 对于普通函数，如果不会使用该函数，则可以只写函数声明而不写函数的定义，但虚函数必须写函数定义
	// 如果用普通对象调用虚函数，则执行的是"静态绑定"，因为在编译期就可以确定调用的具体函数
	
	// 思考1：其实编译期间无法确定父类指针指向的实际对象的类型，也就在编译期间确定调用的实际函数
	// 在下例中，将父类的各个子类对象放入容器中，当取出来使用时，无法确定实际的类型（动态绑定与静态绑定问题）
	// 思考2：如果父类的同名函数是虚函数，则函数隐藏是何种行为（已经回答）
	// 思考3：类的静态成员函数是否能声明为虚函数（理论上来说，不可以）
	// 问题4：假设想要在父类子类中实现虚函数，那么父类子类中函数的返回值类型不同会影响构成虚函数吗？
	// a) 用不同的内置类型作为返回类型进行测试报错：函数的返回类型与重写虚函数的返回类型既不相同，也不协变
	// b) 用一个类作为父类函数的返回值类型，用该类的子类的指针或引用作为子类函数的返回值（尚未测试）
	// 结论：根据规则，一般来说子类对父类某一函数进行重写（覆盖），必须具备相同的返回值类型
	// 但这一规则对协变返回类型却有所放宽，即子类对父类的某一函数进行重写时，子类函数的返回值类型
	// 可以是父类函数返回值类型的子类的指针或者子类的引用，语义上要求子类与父类能够构成一种 is-a 关系

	// (8.3) 多态性(polymorphism)
	// 对于具有继承关系的父类和子类，将父类中的函数声明为虚函数，然后在子类中覆盖父类中的虚函数
	// 在使用过程中，让父类指针指向任意的子类对象，并通过父类指针调用相应的虚函数
	// 在程序运行期确定指针指向对象的具体类型后，再根据对象的具体类型确定实际调用的函数
	// 
	// 多态按字面的意思就是多种形态，可以简单地概括为 "一个接口，多种方法"，它是面向对象编程领域的核心概念
	// 多态性指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作，C++支持两种多态性：编译时多态性，运行时多态性
	// 1) 编译时多态性（静态多态）：通过重载函数实现：先期联编 early binding
	// 2) 运行时多态性（动态多态）：通过虚函数实现 ：滞后联编 late binding
	// PS：静态多态也可以通过函数模板实现（暂时不提及）
	// C++ 运行时多态性是通过虚函数来实现的，虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖(Override)，或者称为重写

	// (8.4) 纯虚函数
	// 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求所有的派生类都要定义该虚函数自己的实现方法（其实就是 java 中的 interface)
	// 一但在类中定义了纯虚函数，那么这个类就成为了一个抽象类，也就不能再生成这个类的实例对象了，抽象类的主要目的是用来统一管理子类对象
	// 格式：virtual void eat() = 0;
	// 总结：
	// 1) 含有纯虚函数的类叫抽象类，不能生成类的实例对象，主要用于作为基类派生出子类对象
	// 2) 子类中必须要实现该基类中定义的纯虚函数

	// （8.5）基类的析构函数一般定义为虚函数（17-> 01：13：26）
	// 深入分析原因，为什么？


}

int main() {
	// 一、类的基本知识
	// test1();

	// 二、构造函数、explicit 与初始化列表
	// test2();

	// 三、inline, const, mutable, this, static
	// test3();

	// 四、类内初始化，默认构造函数，= default
	// test4();

	// 五、拷贝构造函数
	// test5();

	// 六、重载运算符、析构函数
	// test6();
	
	// 七、派生类与访问权限修饰符
	// test7();

	// 八、虚函数、纯虚函数、虚析构函数
	test8();
	return 0;
}
