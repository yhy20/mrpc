#include "man.h"

// 用于进行全局变量、全局函数的二义性测试
// #include "function_hiding.h"
// #include "time.h"

namespace nmsp {

	// 初始化列表无法初始化父类成员
	// 原因分析：主要原因是会造成混乱
	// a) 初始化值的混乱：如果允许使用初始化列表任意初始化父类成员，传递给初始化列表的初值和
	// 传递给父类构造函数的初值如果不同，那么应该选用哪个作为初值？ 这本质上是一个没有意义的问题
		
	// b) 访问权限的混乱：由于父类可能存在 private 成员变量，这些变量并不希望子类的直接访问
	// 如果可以使用初始列表来直接初始化父类的这些 private 成员变量，相当破环了 private 访问权限
	// 如果只允许使用初始列表来直接初始化父类的 public 成员或 protected 成员，那么对于继承第三方
	// 库中的类的情况，如何区分父类的哪些成员是 public 或 protected成员的，哪些又是 private 成员
	 
	// 所以 C++ 中规定了父类的成员变量只能用父类的构造函数初始化，这样不会带来任何混乱 

	// 初始化列表为何效率更高（尤其对于类类型的成员变量）
	// 1） 对于普通成员变量（效率不会有太大影响）
	// 一般情况下，在进入构造函数函数体前，编译器为普通成员分配内存，不过并不初始化，也就是说成员变量
	// 的初始值是随机的。当进入函数体后，再通过赋值语句对普通成员变量进行初始，效率上不会有太大的影响
	// 
	// 2) 对于类类型的成员变量
	// 首先需要明确，在进入构造函数的函数体前，所有的成员变量都已经构建好了
	// a) 在构造函数的函数体中通过赋值进行初始化：构造函数会先调用这些成员变量的 default 构造函数
	// 将对象真正构造出来，然后在构造函数的函数体中调用拷贝赋值运算符进行赋值

	// b) 使用初始化列表进行初始化：在进入构造函数的函数体前，会直接分配内存并初始化值，相比不使用
	// 初始化列表的情况，少调用了一次 default 构造函数

	// 初始化列表的顺序问题
	// 问题，初始化列表中，调用父类构造函数的顺序和初始化成员对象的顺序有要求吗？？？

	Man::Man() /* : m_age(0) */ {
		// 虽然父类的成员变量初始化只能通过调用父类的构造函数
		// 但在子类的构造函数的函数体中可以修改成员变量的值
		std::cout << "Man::Man() 执行！" << std::endl;
	}

	// 调用父类的构造函数来初始化
	// 问题，初始化列表中，调用父类构造函数的顺序和初始化成员对象的顺序有要求吗？？？
	Man::Man(int age, const std::string& name) : Human(age, name) {
		std::cout << "<Man::Man(int) 执行！" << std::endl;
	}

	void Man::man_func() {
		std::cout << "man_func() 执行!" << std::endl;
	}

	void Man::eat() {
		std::cout << "Man eat!" << std::endl;
	}
}

